{
  "hash": "205a86c61c2492fb9fa36ba38a558aea",
  "result": {
    "markdown": "---\ntitle: \"Control Flow\"\n---\n\n\n## Indexing\n\n### Vectors\n\nIn the @sec-r-objects, we discussed about different types of R objects. For example, a vector can be a certain data type with a set number of elements. Here we construct a vector called `x` increasing from -5 to 5 by one unit:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(x <- -5:5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] -5 -4 -3 -2 -1  0  1  2  3  4  5\n```\n:::\n:::\n\n\nThe vector `x` has 11 elements. If I want to know what the 6th element of `x`, I can index the 6th element from a vector. To do this, we use `[]` square brackets on `x` to index it. For example, we index the 6th element of `x`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[6]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n\nWhen ever we use `[]` next to an R object, it will print out the data to a specific value inside the square brackets. We can index an R object with multiple values:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -5 -4 -3\n```\n:::\n\n```{.r .cell-code}\nx[c(3,9)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -3  3\n```\n:::\n:::\n\n\nNotice how the second line uses the `c()`. This is necessary when we want to specify non-contiguous elements. Now let's see how we can index a matrix\n\n### Matrices\n\nA matrix can be indexed the same way as a vector using the `[]` brackets. However, since the matrix is a 2-dimensional objects, we will need to include a comma to represent the different dimensions: `[,]`. The first element indexes the row and the second element indexes the columns. To begin, we create the following $4 \\times 3$ matrix:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(x <- matrix(1:12, nrow = 4, ncol = 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    5    9\n[2,]    2    6   10\n[3,]    3    7   11\n[4,]    4    8   12\n```\n:::\n:::\n\n\nNow to index the element at row 2 and column 3, use `x[2, 3]`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[2, 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n:::\n\n\nWe can also index a specific row and column:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[2,]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  6 10\n```\n:::\n\n```{.r .cell-code}\nx[,3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  9 10 11 12\n```\n:::\n:::\n\n\n### Data Frames\n\nThere are several ways to index a data frame, since it is in a matrix format, you can index it the same way as a matrix. Here are a couple of examples using the `mtcars` data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars[,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4\n```\n:::\n\n```{.r .cell-code}\nmtcars[2,]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n              mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4 Wag  21   6  160 110  3.9 2.875 17.02  0  1    4    4\n```\n:::\n:::\n\nHowever, a data frame has labeled components, variables, we can index the data frame with the variable names within the brackets:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars[, \"cyl\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4\n```\n:::\n:::\n\n\nLastly, a data frame can be indexed to a specific variable using the `$` notation as described in @sec-basic-data-frames.\n\n### Lists\n\nAs described in @sec-basics-lists, lists contain elements holding different R objects. To index a specific element of a list, you will use `[[]]` double brackets. Below is a toy list:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntoy_list <- list(mtcars = mtcars,\n                 vector = rep(0, 4),\n                 identity = diag(rep(1, 3)))\n```\n:::\n\n\n\nTo access the second element, vector element, you can type `toy_list[[2]]`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntoy_list[[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0 0 0 0\n```\n:::\n:::\n\nSince the elements are labeled within the list, you can place the label in quotes inside `[[]]`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntoy_list[[\"vector\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0 0 0 0\n```\n:::\n:::\n\n\nThe element can be accessed using the `$` notation with a list:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntoy_list$vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0 0 0 0\n```\n:::\n:::\n\n\nLastly, you can further index the list if needed, we can access the `mpg` variable in `mtcars` from the `toy_list`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntoy_list$mtcars$mpg\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4\n[16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7\n[31] 15.0 21.4\n```\n:::\n\n```{.r .cell-code}\ntoy_list[[\"mtcars\"]]$mpg\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4\n[16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7\n[31] 15.0 21.4\n```\n:::\n\n```{.r .cell-code}\ntoy_list$mtcars[,'mpg']\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4\n[16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7\n[31] 15.0 21.4\n```\n:::\n:::\n\n\n\n## If/Else Statements\n\n\nIn R, there are control flow functions that will dictate how a program will be executed.\nThe first set of functions we will talk about are `if` and `else` statements. First, the `if` statement will evaluate a task, If the conditions is satisfied, yields `TRUE`, then it will conduct a certain task, if it fails, yields `FALSE`, the `else` statement will guide it to a different task. Below is a general format:\n\n\n\n:::{.callout-note icon=\"false\"}\n## Important Concept\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (condition) {\n  TRUE task\n} else {\n  FALSE task\n}\n```\n:::\n\n:::\n\n\n\n### Example\n\nBelow is an example where we generate `x` from a standard normal distribution and print the statement 'positive' or  'non-positive' based on the condition `x > 0`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rnorm(1)\n\n## if statements\nif (x > 0){\n  print(\"Positive\")\n} else {\n  print(\"Non-Positive\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Non-Positive\"\n```\n:::\n:::\n\n\nWhat if we want to print the statement 'negative' as well if the value is negative? We will then need to add another `if` statement after the `else` statement since `x > 0` only lets us know if the value is positive.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rnorm(1)\n\nif (x > 0){\n  print(\"Positive\")\n} else if (x < 0) {\n  print(\"Negative\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Negative\"\n```\n:::\n:::\n\n\nAbove, we add the `if` statement with condition `(x < 0)` indicating if the number is negative. Lastly, if `x` is ever $0$, we will want R to let us know it is $0$. We can achieve this by adding one last `else` statement:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rnorm(1)\n\nif (x > 0){\n  print(\"Positive\")\n} else if (x < 0) {\n  print(\"Negative\")\n} else {\n  print(\"Zero\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Positive\"\n```\n:::\n:::\n\n\n## `for` loops\n\nA for `loop` is a way to repeat a task a certain amount of times. Every time a loop repeats a task, we state it is an iteration of the loop. For each iteration, we may change the inputs by a certain way, either from an indexed vector, and repeat the task. The general anatomy of a loop looks like:\n\n\n:::{.callout-note appearance='default' icon=false}\n## Important Concept\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in vector){\n  perform task\n}\n```\n:::\n\n:::\n\n\nThe `for` statement indicates that you will repeat a task inside the brackets. The `i` in the parenthesis controls how the task will be completed. The `in` statement tells R where `i` can look for the values, and `vectorr` is a vector R object that contains the values `i` can be. It also controls how many times the task will be repeated based on the length of the vector.  \n\nLearning about a loop is quite challenging, my recommendation is to read the section below and break the example code so you can understand how a `for` loop works.\n\n### Basic `for` loop\n\nLet's say we want R to print one to five separately. We can achieve this by repeating the `print()` 5 times.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(1); print(2); print(3); print(4); print(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\nHowever, this takes quite awhile to type up. Let's try to achieve the same task using a `for` loop. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:5){\n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n```\n:::\n:::\n\n\nHere, `i` will take a value from the vector `1:5`,^[Type this in the console to see what it is.] Then, R will print out what the value of `i` is.\n\nNow, let's try another example with letters. To begin, create a new vector called `letters_10` containing the first 10 letters of the alphabet. Use the vector `letters` to construct the neww vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nletters_10 <- letters[1:10]\n```\n:::\n\n\nNow, we will use a loop to print out the first 10 letters:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:10) {\n  print(letters_10[i])\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\"\n[1] \"b\"\n[1] \"c\"\n[1] \"d\"\n[1] \"e\"\n[1] \"f\"\n[1] \"g\"\n[1] \"h\"\n[1] \"i\"\n[1] \"j\"\n```\n:::\n:::\n\n\nHere, we have `i` take on the values 1 through 10. Using those values, we will index the vector `letters_10` by `i`. The resulting letter will then be printed. This task repeated 10 times.\n\nLastly, we can replace `1:10` by `letters_10` instead:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in letters_10){\n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\"\n[1] \"b\"\n[1] \"c\"\n[1] \"d\"\n[1] \"e\"\n[1] \"f\"\n[1] \"g\"\n[1] \"h\"\n[1] \"i\"\n[1] \"j\"\n```\n:::\n:::\n\n\nThis is because `letters_10` are the values that we want to print and `i` takes on the value of `letters_10` each time.\n\n### Nested `for` loops\n\nA nested `for` loop is a loop that contain a loop within. Below is an example of 3 `for` loops nested within each other. Below is a general example:\n\n\n:::{.callout-note appearance='default' icon=\"false\"}\n## Important Concept\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in vector_1) {\n  for (ii in vector_2) {\n    for (iii in vector_3) {\n      perform task\n    }\n  }\n}\n```\n:::\n\n\n:::\n\n\nAs an example, we will use the `greekLetter::`^[`install.packages(greekLetters)`] and use the `greek_vector` vector to obtain greek letters in R. Lastly, create a vector called `greek_10`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(greekLetters)\ngreek_10 <- greek_vector[1:10]\n```\n:::\n\n\n\nFor this example, we want R to print \"a\" and \"$\\alpha$\" together as demonstrated below^[We will need to use `paste0()` to combine the letters together.]:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(paste0(letters_10[1], greek_10[1]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"aα\"\n```\n:::\n:::\n\n\nNow let's repeat this process to print all possible combinations of the first 3 letters and 3 greek letters:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:3){\n  for (ii in 1:3){\n    print(paste0(letters_10[i], greek_10[ii]))\n  }\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"aα\"\n[1] \"aβ\"\n[1] \"aγ\"\n[1] \"bα\"\n[1] \"bβ\"\n[1] \"bγ\"\n[1] \"cα\"\n[1] \"cβ\"\n[1] \"cγ\"\n```\n:::\n:::\n\n\n\n## `break`\n\nA `break` statement is used to stop a loop midway if a certain condition is met. A general setup of `break` statement goes as follows: \n\n:::{.callout-note appearance='default' icon=\"false\"}\n## Important Concept\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in vector){\n  if (condition) {break}\n  else {\n    task\n  }\n}\n```\n:::\n\n:::\n\nAs you can see there is an `if` statement in the loop. This is used to tell R when to break the loop. If the `if` statement was not there, then the loop will break without iterating. \n\nTo demonstrate the break statement, we will simulate from a $N(1,1)$ until we have 30 positive numbers or we simulate a negative number.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rep(NA,length = 30)\n\nfor (i in seq_along(x)){\n  y <- rnorm(1,1)\n  if (y<0) {\n    break\n  }\n  else {\n    x[i] <- y\n  }\n}\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0.9773483 1.7917295 1.2907964 2.6436599 0.8576497 2.0094081 2.2106120\n [8] 1.5479097        NA        NA        NA        NA        NA        NA\n[15]        NA        NA        NA        NA        NA        NA        NA\n[22]        NA        NA        NA        NA        NA        NA        NA\n[29]        NA        NA\n```\n:::\n\n```{.r .cell-code}\nprint(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.1423665\n```\n:::\n:::\n\n\nNotice that the vector does not get filled up all the way, that is because the loop will break once a negative number is simulated\n\n## `next`\n\nSimilar to the `break` statement, the `next` statement is used in loops that will tell R to move on to the next iteration if a certain condition is met. \n\n:::{.callout-note appearance='default' icon=\"false\"}\n## Important Note\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in vector){\n  if (condition) {\n    next\n  } else {\n    task\n  }\n}\n```\n:::\n\n\n:::\n\nThe main difference here is that a `next` statement is used instead of a `break` statement.\n\nGoing back to simulating positive numbers, we will use the same setup but change it to a `next` statement.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rep(NA,length = 30)\n\nfor (i in seq_along(x)){\n  y <- rnorm(1,1)\n  if (y<0) {\n    next\n  }\n  else {\n    x[i] <- y\n  }\n}\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0.91270459 3.08197264 0.72089222 0.18219414 0.23886831 1.36808335\n [7] 3.40865796 0.27035560         NA         NA 1.56910622 1.27601839\n[13] 1.93305823 0.77069335 1.41109492 1.97015699 1.51544717 1.24035773\n[19]         NA         NA 0.05664593 1.96861889 1.14983838 1.10942886\n[25] 1.16644878 0.29784533 0.48227478 1.51119269 1.30830747 1.39608537\n```\n:::\n:::\n\n\nAs you can see, the vector contains missing values, these were the iterations that a negative number was simulated. \n\n## `while` loop\n\nThe last loop that we will discuss is a while loop. The while loop is used to keep a loop running until a certain condition is met. To construct a while loop, we will use the `while` statement with a condition attached to it. In general, a while loop will have the following format:\n\n:::{.callout-note appearance='default' icon=false}\n## Important Concept\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhile (condition) {\n  task\n  update condition\n}\n```\n:::\n\n\n:::\n\nAbove, we see that the `while` statement is used followed by a condition. Then the loop will complete its task and update the condition. If the condition yields a `FALSE` value, then the loop will stop. Otherwise, it will continue.\n\n\n### Basic `while` loops\n\nTo implement a basic `while` loop, we will work on the previous example of simulating positive numbers. We want to simulate 30 positive numbers from $N(0,1)$ until we have 30 values. Here, our condition is that we need to have 30 numbers. Therefore we can use the following code to simulate the values:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c()\nsize <- 0\nwhile (size < 30){\n  y <- rnorm(1) \n  if (y > 0) {\n    x <- c(x, y)\n  }\n  size <- length(x)\n}\nprint(size)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 30\n```\n:::\n\n```{.r .cell-code}\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0.005245146 0.280625589 0.526876606 0.822030249 2.246205824 1.952491935\n [7] 0.670100699 2.311234135 0.688772123 0.320199750 1.397227140 0.830938390\n[13] 0.178526953 0.478543903 0.329451783 0.170460111 0.838914598 0.532007459\n[19] 1.308559454 1.807544365 0.102020257 0.556702144 0.914246544 1.661145724\n[25] 0.128944880 0.479945924 0.034947857 0.153277439 0.011630151 0.856472034\n```\n:::\n:::\n\nNotice that we do not use an `else` statement. This is because we do not need R to complete a task if the condition fails.\n\n### Infinite `while` loops\n\nWith while loops, we must be weary about potential infinite loops. This occurs when the condition will never yield a `FALSE` value. Therfore, R will never stop the loop because it does not know when to do this. \n\nFor example, let's say we are interest if $y=sin(x)$ will converge to a certain value. As you know it will not converge to a certain value; however, we can construct a while loop: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1\ndiff <- 1\nwhile (diff > 1e-20) {\n  old_x <- x\n  x <- x + 1\n  diff <- abs(sin(x) - sin(old_x))\n}\nprint(x)\nprint(diff)\n```\n:::\n\n\nMy condition above is to see if the absolute difference between sequential values is smaller than $10^{-20}$. As you may know, the absolute difference will never become that small. Therefore, the loop will continue on without stopping.\n\n\nTo prevent an infinite while loop, we can add a counter to the condition statement. This counter will also need to be true for the loop to continue. Therefore, we can arbitrarily stop it when the loop has iterated a certain amount of times.  We just need to make sure to add one to the counter every time it iterates it. Below is the code that adds a counter to the while loop:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1\ncounter <- 0\ndiff <- 1\nwhile (diff > 1e-20 & counter < 10^3) {\n  old_x <- x\n  x <- x + 1\n  diff <- abs(sin(x) - sin(old_x))\n  counter <- counter + 1\n}\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1001\n```\n:::\n\n```{.r .cell-code}\nprint(diff)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.09311106\n```\n:::\n\n```{.r .cell-code}\nprint(counter)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1000\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}